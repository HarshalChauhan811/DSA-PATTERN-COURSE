# Day 2 ‚Äî **Two-Pointer Patterns ** üß†‚ú®

> **All Problems Solved Using Two-Pointer Approach ‚Äî Colorful VSCode-Styled C++ Code üí°**

---

## üß≠ Table of Contents

1. Two-Pointer Pattern ‚Äî Quick Recipe üç≥  
2. Problems (All Two-Pointer Based)
   * 2.1 ‚úÖ Valid Palindrome  
   * 2.2 üîÅ Reverse String  
   * 2.3 üî≤ Squares of a Sorted Array  
   * 2.4 üõ†Ô∏è Valid Palindrome II  
   * 2.5 ‚úçÔ∏è Valid Word Abbreviation  
3. Tips & Pitfalls üìå  
4. Quick Summary Sheet ‚è±Ô∏è  

---

# 1Ô∏è‚É£ Two-Pointer Pattern ‚Äî Quick Recipe üç≥

**Where to Use:** Arrays, Strings, Linked Lists (Linear Data)

**How it Works:**

* Start two pointers: `i = 0` (left), `j = n - 1` (right)
* Move both based on logic or condition
* Continue until `i >= j`

**General Template:**

```cpp
int i = 0, j = n - 1;
while (i < j) {
    // check condition
    // move pointers
}
‚úÖ Time: O(n) | Space: O(1)

2Ô∏è‚É£ Problems ‚Äî All Using Two-Pointer üî•
2.1 ‚úÖ Valid Palindrome
Why Two-Pointer? Need to compare both ends for equality.

Logic:

i ‚Üí start, j ‚Üí end

Ignore non-alphanumeric characters

Compare lowercase values

Mismatch ‚Üí false, else continue

C++ Code:

cpp
Copy code
#include <bits/stdc++.h>
using namespace std;

bool isPalindrome(string s) {
    int i = 0, j = s.size() - 1;
    while (i < j) {
        if (!isalnum(s[i])) { i++; continue; }
        if (!isalnum(s[j])) { j--; continue; }
        if (tolower(s[i]) != tolower(s[j])) return false;
        i++; j--;
    }
    return true;
}
‚úÖ Example: "A man, a plan, a canal: Panama" ‚Üí true

2.2 üîÅ Reverse String (In-Place)
Why Two-Pointer? Swap both ends till middle.

Logic:

i = 0, j = n-1

Swap characters

Move both pointers toward center

C++ Code:

cpp
Copy code
#include <bits/stdc++.h>
using namespace std;

void reverseString(vector<char>& s) {
    int i = 0, j = s.size() - 1;
    while (i < j) {
        swap(s[i], s[j]);
        i++; j--;
    }
}
‚úÖ Example: [h, e, l, l, o] ‚Üí [o, l, l, e, h]

2.3 üî≤ Squares of a Sorted Array
Why Two-Pointer? Largest squares appear at both ends.

Logic:

i = 0, j = n-1, k = n-1

Compare abs(nums[i]) & abs(nums[j])

Bigger square ‚Üí store at res[k--]

C++ Code:

cpp
Copy code
#include <bits/stdc++.h>
using namespace std;

vector<int> sortedSquares(vector<int>& nums) {
    int n = nums.size();
    vector<int> res(n);
    int i = 0, j = n - 1, k = n - 1;
    while (i <= j) {
        if (abs(nums[i]) > abs(nums[j])) {
            res[k--] = nums[i] * nums[i];
            i++;
        } else {
            res[k--] = nums[j] * nums[j];
            j--;
        }
    }
    return res;
}
‚úÖ Example: [-4, -1, 0, 3, 10] ‚Üí [0, 1, 9, 16, 100]

2.4 üõ†Ô∏è Valid Palindrome II
Why Two-Pointer? Compare both ends, allow one deletion.

Logic:

Normal palindrome check

On mismatch ‚Üí try skipping left once OR right once

C++ Code:

cpp
Copy code
#include <bits/stdc++.h>
using namespace std;

bool isPal(string &s, int i, int j) {
    while (i < j) {
        if (s[i] != s[j]) return false;
        i++; j--;
    }
    return true;
}

bool validPalindrome(string s) {
    int i = 0, j = s.size() - 1;
    while (i < j) {
        if (s[i] != s[j]) {
            return isPal(s, i + 1, j) || isPal(s, i, j - 1);
        }
        i++; j--;
    }
    return true;
}
‚úÖ Example: abca ‚Üí remove ‚Äòb‚Äô ‚Üí true

2.5 ‚úçÔ∏è Valid Word Abbreviation
Why Two-Pointer? Move through both strings together.

Logic:

i on word, j on abbr

If abbr[j] is letter ‚Üí match

If digit ‚Üí read full number, skip in word

Both must end together

C++ Code:

cpp
Copy code
#include <bits/stdc++.h>
using namespace std;

bool validWordAbbreviation(string word, string abbr) {
    int i = 0, j = 0;
    while (i < word.size() && j < abbr.size()) {
        if (isdigit(abbr[j])) {
            if (abbr[j] == '0') return false;
            int num = 0;
            while (j < abbr.size() && isdigit(abbr[j])) {
                num = num * 10 + (abbr[j] - '0');
                j++;
            }
            i += num;
        } else {
            if (word[i] != abbr[j]) return false;
            i++; j++;
        }
    }
    return i == word.size() && j == abbr.size();
}
‚úÖ Example: word = ‚Äúinternational‚Äù, abbr = ‚Äúi12l‚Äù ‚Üí true

3Ô∏è‚É£ Tips & Pitfalls üìå
‚úÖ Always explain why two-pointer suits the problem.

‚ö†Ô∏è Use static_cast<unsigned char> with isalnum safely.

‚úÖ Dry run examples (interviewer loves clarity).

‚úÖ Mention time & space complexity.

‚úÖ Don‚Äôt forget bounds check when skipping indices.

4Ô∏è‚É£ Quick Summary Sheet ‚è±Ô∏è
Problem	Approach	Time	Space
Valid Palindrome	Compare ends skipping non-alnum	O(n)	O(1)
Reverse String	Swap till middle	O(n)	O(1)
Squares Array	Compare abs ends, fill from back	O(n)	O(n)
Valid Palindrome II	Skip one char on mismatch	O(n)	O(1)
Word Abbreviation	Move both pointers	O(n + m)	O(1)

üí• Final Tip: Har problem me two-pointer ka reason clearly likho aur example ke sath explain karo ‚Äî interviewer ko lagega tum pattern-based soch rakhte ho üöÄ